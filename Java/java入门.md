# JAVA学习笔记（NUTPrince）

  

## JDK、JRE、JVM

  

### JDK

  

> JDK 的全称(Java Development Kit Java 开发工具包) 

  

​      JDK = JRE + java 的开发工具 [java, javac,javadoc,javap 等]

  

###JRE

  

> JRE(Java Runtime Environment Java 运行环境) JRE = JVM + Java 的核心类库[类] 

  

  

  

### JVM

  

> JVM是Java Virtual Machine（Java虚拟机)

  

Java虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。

  

###JDK、JRE 和 JVM 的包含关系

  

1. JDK = JRE + 开发工具集（例如 Javac,java 编译工具等)

2. JRE = JVM + Java SE 标准类库（java 核心类库）

3. 如果只想运行开发好的 .class 文件 只需要 JRE

  

## 安装JDK，配置环境变量

  

1. 安装JDK

    [JDK下载](https://www.oracle.com/java/technologies/downloads/#jdk17-windows)

  

  > 默认安装，也可选安装在其他盘（记住路径，配置环境变量需要用到）

  

2. 配置环境变量

  + 此电脑->属性->高级系统设置->环境变量


  > 在系统变量中
  >  
  > 点击新建->变量名：JAVA_HOME,变量名：安装路径，确定

  ![](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png)

  > 再双击path
  
  ![](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png)

  > 点击新建
  
  ![](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png)

  > 输入：%JAVA_HOME%\bin,确定
  
  ![](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F4.png)

  - 测试

  > win+R键，输入cmd回车
  > 输入java回车

 ![测试1](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E6%B5%8B%E8%AF%951.png)

  >输入javac回车

  ![测试2](https://gitee.com/nutprince/image/raw/master/JAVA_Image/%E6%B5%8B%E8%AF%952.png)

  

## JAVA运行机制

  

  ![java运行机制](https://gitee.com/nutprince/image/raw/master/JAVA_Image/java%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png)

  

## 第一个Java程序—helloworld

  

```java

public calss Helloworld{

    public static void main(String[] args){

        System.out.println("helloworld!");

    }

}

```

  

![662E827A-FA32-4464-B0BD-40087F429E98](https://gitee.com/nutprince/image/raw/master/JAVA_Image/202201150055352.jpg)

  

## Java基本语法

  

编写 Java 程序时，应注意以下几点：

  

+ **大小写敏感**：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。

+ **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 **MyFirstJavaClass** 。

+ **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。

+ **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）。

+ **主方法入口**：所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。

  

## Java 标识符

  

Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

  

关于 Java 标识符，有以下几点需要注意：

  

+ 所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始

+ 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合

+ 关键字不能用作标识符

+ 标识符是大小写敏感的

+ 合法标识符举例：age、$salary、_value、__1_value

+ 非法标识符举例：123abc、-salary

  

## Java 关键字

  

下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。

| **类别** | **关键字** |
|:---:|:---:|
| private | 访问控制 |
| protected | 受保护的 |
| public | 公共的 |
| default | 默认 |
| class | 类 |
| extends | 扩充,继承 |
| final | 最终值,不可改变的 |
| implements | 实现（接口） |
| interface | 接口 |
| native | 本地，原生方法（非 Java 实现） |
| new | 新,创建 |
| static | 静态 |
| strictfp | 严格,精准 |
| synchronized | 线程,同步 |
| transient | 短暂 |
| volatile | 易失 |
| continue | 继续 |
| default | 默认 |
| do | 运行 |
| else | 否则 |
| for | 循环 |
| if | 如果 |
| instanceof | 实例 |
| return | 返回 |
| switch | 根据值选择执行 |
| while | 循环 |
| catch | 捕捉异常 |
| finally | 有没有异常都执行 |
| throw | 抛出一个异常对象 |
| throws | 声明一个异常可能被抛出 |
| try | 捕获异常 |
| package | 包 |
| byte | 字节型 |
| char | 字符型 |
| double | 双精度浮点 |
| float | 单精度浮点 |
| int | 整型 |
| long | 长整型 |
| short | 短整型 |
| this | 本类 |
| void | 无返回值 |


  

**注意：**Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。

  

## Java注释

  

注释中的字符将被 Java 编译器忽略。

  

+ 单行注释

  

  ```java

  //这是一个不会被编译的注释

  ```

  

+ 多行注释

  

  ```java

  /*

  这是一个不会被编译的注释

  */

  ```

  

+ 文档注释

  

  ```java

  /**这是一个不会被编译的注释

  *@auther:NUTPrice

  *@version:1.0

  */

  ```

  

  > Java 支持三种注释方式。前两种分别是 **//** 和 **/\* \*/**，第三种被称作说明注释，它以 **/\**** 开始，以 ***/**结束。

  >

  > 说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。

  >

  > 说明注释，使你更加方便的记录你的程序信息。

  

  javadoc 工具软件识别以下标签：

  

  | **标签**      |                        **描述**                        |                           **示例**                           |

  | :------------ | :----------------------------------------------------: | :----------------------------------------------------------: |

  | @author       |                    标识一个类的作者                    |                     @author description                      |

  | @deprecated   |                 指名一个过期的类或成员                 |                   @deprecated description                    |

  | {@docRoot}    |                指明当前文档根目录的路径                |                        Directory Path                        |

  | @exception    |                  标志一个类抛出的异常                  |            @exception exception-name explanation             |

  | {@inheritDoc} |                  从直接父类继承的注释                  |      Inherits a comment from the immediate surperclass.      |

  | {@link}       |               插入一个到另一个主题的链接               |                      {@link name text}                       |

  | {@linkplain}  |  插入一个到另一个主题的链接，但是该链接显示纯文本字体  |          Inserts an in-line link to another topic.           |

  | @param        |                   说明一个方法的参数                   |              @param parameter-name explanation               |

  | @return       |                     说明返回值类型                     |                     @return explanation                      |

  | @see          |               指定一个到另一个主题的链接               |                         @see anchor                          |

  | @serial       |                   说明一个序列化属性                   |                     @serial description                      |

  | @serialData   | 说明通过writeObject( ) 和 writeExternal( )方法写的数据 |                   @serialData description                    |

  | @serialField  |             说明一个ObjectStreamField组件              |              @serialField name type description              |

  | @since        |               标记当引入一个特定的变化时               |                        @since release                        |

  | @throws       |                 和 @exception标签一样.                 | The @throws tag has the same meaning as the @exception tag.  |

  | {@value}      |         显示常量的值，该常量必须是static属性。         | Displays the value of a constant, which must be a static field. |

  | @version      |                      指定类的版本                      |                        @version info                         |

  

## Java 基本数据类型

  

> 变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。

>

> 内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。

>

> 因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。

  

Java 的两大数据类型:

  

+ 内置数据类型

  

+ 引用数据类型

  

  

**类型默认值**

  

下表列出了 Java 各个类型的默认值：

  

| **数据类型**           | **默认值** |

| :--------------------- | :--------- |

| byte                   | 0          |

| short                  | 0          |

| int                    | 0          |

| long                   | 0L         |

| float                  | 0.0f       |

| double                 | 0.0d       |

| char                   | 'u0000'    |

| String (or any object) | null       |

| boolean                | false      |

类型默认值

下表列出了 Java 各个类型的默认值：

  

**自动类型转换**

  

> 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。

  

转换从低级到高级。

  

```

低  ------------------------------------>  高

  

byte,short,char—> int —> long—> float —> double 

```

## Java 变量类型

  

> 在Java语言中，所有的变量在使用前必须声明。

  

Java语言支持的变量类型有：

  

+ 类变量：独立于方法之外的变量，用 static 修饰。

+ 实例变量：独立于方法之外的变量，不过没有 static 修饰。

+ 局部变量：类的方法中的变量。

  

## Java 运算符

  

计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：

  

+ 算术运算符

+ 关系运算符

+ 位运算符

+ 逻辑运算符

+ 赋值运算符

+ 其他运算符

  

### 算术运算符

  

> 算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。

  

下表列出了所有的算术运算符。

  

| 操作符 | 描述                              |

| :----- | :-------------------------------- |

| +      | 加法 - 相加运算符两侧的值         |

| -      | 减法 - 左操作数减去右操作数       |

| *      | 乘法 - 相乘操作符两侧的值         |

| /      | 除法 - 左操作数除以右操作数       |

| ％     | 取余 - 左操作数除以右操作数的余数 |

| ++     | 自增: 操作数的值增加1             |

| --     | 自减: 操作数的值减少1             |

  

### 自增自减运算符

  

**1、自增（++）自减（--）运算符**:是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。

  

**2、前缀自增自减法(++a,--a):** 先进行自增或者自减运算，再进行表达式运算。

  

**3、后缀自增自减法(a++,a--):** 先进行表达式运算，再进行自增或者自减运算。

  

### 关系运算符

  

下表为Java支持的关系运算符

  

```java

int a = 10,b = 20;

```

  

| 运算符 | 例子             |

| :----- | :--------------- |

| ==     | （A == B）为假。 |

| !=     | (A != B) 为真。  |

| >      | （A> B）为假。   |

| <      | （A <B）为真。   |

| >=     | （A> = B）为假。 |

| <=     | （A <= B）为真。 |

  

### 位运算符

  

Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。

  

位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下：

  

```

A = 0011 1100

B = 0000 1101

-----------------

A&B = 0000 1100

//同时为1->才取1，否则为0

  

A | B = 0011 1101

//同时为0->才取0，否则为1

  

A ^ B = 0011 0001

//同则为0，不同为1

  

~A= 1100 0011

//取反

```

  

下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

  

| 操作符 | 描述                                                         | 例子                           |

| :----- | :----------------------------------------------------------- | :----------------------------- |

| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |

| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |

| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |

| ～     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （～A）得到-61，即1100 0011    |

| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |

| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |

| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

  

### 逻辑运算符

  

下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假

  

| 操作符 | 描述                                                         | 例子                |

| :----- | :----------------------------------------------------------- | :------------------ |

| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | （A && B）为假。    |

| \| \|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |

| ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

  

### 条件运算符

  

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

  

```java

variable x = (expression) ? value if true : value if false

```

  

### Java运算符优先级

  

当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

  

例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。

  

再如，x = 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。

  

下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。

  

| 类别     | 操作符                                     | 关联性   |

| :------- | :----------------------------------------- | :------- |

| 后缀     | () [] . (点操作符)                         | 左到右   |

| 一元     | expr++ expr--                              | 从左到右 |

| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |

| 乘性     | * /％                                      | 左到右   |

| 加性     | + -                                        | 左到右   |

| 移位     | >> >>>  <<                                 | 左到右   |

| 关系     | > >= < <=                                  | 左到右   |

| 相等     | == !=                                      | 左到右   |

| 按位与   | ＆                                         | 左到右   |

| 按位异或 | ^                                          | 左到右   |

| 按位或   | \|                                         | 左到右   |

| 逻辑与   | &&                                         | 左到右   |

| 逻辑或   | \| \|                                      | 左到右   |

| 条件     | ？：                                       | 从右到左 |

| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |

| 逗号     | ，                                         | 左到右   |

  

## JAVA流程控制

  

### 输出

  

> 格式化输出使用`System.out.printf()`

  

- Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：

  

|占位符|说明|

|:----|----|

|%d|格式化输出整数|

|%x|格式化输出十六进制整数|

|%f|格式化输出浮点数|

|%e|格式化输出科学计数法表示的浮点数|

|%s|格式化字符串|

  

例如：

```java

public class Main {

    public static void main(String\[\] args) {  

        int n = 12345000;   

        System.out.printf("n=%d, hex=%08x", n, n); // 注意，两个%占位符必须传入两个数

    }

}

  

```

  

### 输入

  

> 和输出相比，Java的输入就要复杂得多。

  

```java

import java.util.Scanner;

  

public class Main {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in); // 创建Scanner对象

        System.out.print("Input your name: "); // 打印提示

        String name = scanner.nextLine(); // 读取一行输入并获取字符串

        System.out.print("Input your age: "); // 打印提示

        int age = scanner.nextInt(); // 读取一行输入并获取整数

        System.out.printf("Hi, %s, you are %d\n", name, age); // 格式化输出

    }

}

```

  

首先，我们通过`import`语句导入`java.util.Scanner`，`import`是导入某个类的语句，必须放到Java源代码的开头。

  

然后，创建`Scanner`对象并传入`System.in`。`System.out`代表标准输出流，而`System.in`代表标准输入流。

  

直接使用`System.in`读取用户输入虽然是可以的，但需要更复杂的代码，而通过`Scanner`就可以简化后续的代码。

  

有了`Scanner`对象后，要读取用户输入的字符串，使用`scanner.nextLine()`，要读取用户输入的整数，使

  

用`scanner.nextInt()`。Scanner会自动转换数据类型，因此不必手动转换。

  

### if判断

  

**if...(else if)...(else) 语句**

  

**if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。**

  

> 使用 if，else if，else 语句的时候，需要注意下面几点：

  

- if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。

- if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。

- 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。

  

### switch多重选择

  

`switch`语句根据`switch (表达式)`计算的结果，跳转到匹配的`case`结果，然后继续执行后续语句，直到遇到`break`结束执行。

  

使用`switch`时，注意`case`语句并没有花括号`{}`，而且，`case`语句具有“_穿透性_”，漏写`break`将导致意想不到的结果。

  

### switch表达式

  

使用`switch`时，如果遗漏了`break`，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要`break`语句：

  

```java

public class Main {

public static void main(String\[\] args) {

  

    String fruit = "apple";

  

    switch (fruit) {

  

    case "apple" -> System.out.println("Selected apple");

  

    case "pear" -> System.out.println("Selected pear");

  

    case "mango" -> {

  

        System.out.println("Selected mango");

  

        System.out.println("Good choice!");

  

    }

  

    default -\> System.out.println("No fruit selected");

  

    }

}

}

```

  

### while循环

  

while是最基本的循环，它的结构为：

  

```java

while( 布尔表达式 ) { 

  //循环内容 

}

```

  

只要布尔表达式为 true，循环就会一直执行下去。

  

### do…while 循环

  

对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。

  

do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。

  

```

do {

       //代码语句

}while(布尔表达式);

```

  

**注意：**布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。

  

###  for循环

  

虽然所有循环结构都可以用 while 或者 do...while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。

  

for循环执行的次数是在执行前就确定的。语法格式如下：

  

```java

for(初始化; 布尔表达式; 更新) {    //代码语句 }

```

  

  

关于 for 循环有以下几点说明：

  

- 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。

- 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。

- 执行一次循环后，更新循环控制变量。

- 再次检测布尔表达式。循环执行上面的过程。

  

### 增强 for 循环

  

Java 增强 for 循环语法格式如下:

  

```java

for(声明语句 : 表达式) {   

  //代码句子

}

```

  

  

  

**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。

  

**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。

  

### break 关键字

  

break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。

  

break 跳出最里层的循环，并且继续执行该循环下面的语句。

  

### continue 关键字

  

continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。

  

在 for 循环中，continue 语句使程序立即跳转到更新语句。

  

在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。

  

## 面向对象

  

![未命名文件](https://gitee.com/NUTPrince/image/raw/master/JAVA_Image/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg)

  

静态的属性 ->  属性

  

动态的行为 ->  方法

  

静态代码块（只会初次加载一次  ）->匿名代码块->构造代码块

## 抽象

程序员开发出来的软件是需要满足用户需求的，所以程序员做分析和设计的依据是用户需求，这通常就是软件开发前期形成的“需求规格说明书”。面向对象设计时，首先要阅读用户需求，找出需求中名词部分用来确定类和拥有静态特征的属性，找出动词部分确定动态行为的方法。

首先要进行抽象，就是发现类并定义类的属性和方法。具体的步骤如下。

1.  发现名词。通过阅读需求，发现需求中有类型、轿车、卡车、品牌、红旗、长城、吨位、车名、油量、车损度等名词。

2.  确定类和属性。通过分析，车名、油量、车损度、品牌这些名词依附于轿车这个名词，车名、油量、车损度、吨位依附于卡车这个名词，所以可以将轿车、卡车抽象成类，依附于这些类的名词抽象成属性。需要补充一点，不是所有依附于类的名词都需要抽象成属性，因为在分析需求的过程中会发现其中某些名词不需要关注，则在抽象出类的过程中放弃这些名词，不将其抽象成属性。例如红旗、长城，这是两个轿车的品牌，属于属性值，不需要抽象成类或属性。

3.  确定方法。通过分析需求的动词，发现显示车辆信息是轿车和卡车的行为，所以可以将这个行为抽象成类的方法。同样地，不是所有依附于类名词的动词都需要抽象成类的方法，只有需要参与业务处理的动词才能确定成方法。

## 封装

在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。

要访问该类的代码和数据，必须通过严格的接口控制。

封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。

适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

抽象的目的在于设计类的框架，确定属性和方法，而接下来的封装，则要隐藏类的属性或部分方法。

最简单的操作方法就是，把所有的属性都设置为私有属性，每个私有属性都提供 getter 和 setter 公有的方法，封装后的类图如下图所示，在类图中设定了类的成员变量的初始值。

## 总结

抽象，实际上是一个分析的过程，是根据需求的表述归纳实体的类型、属性和行为，其产出物是类图。类图勾勒了实体应该具备哪些属性和行为，但未涉及细节。

而封装，实则就是将抽象得到的模型转变为具体实现。它的要点是，尽可能对外隐藏细节，Java 中的手段就是使用 private，所以在上述案例中所有的属性都是 private。但是否简单粗暴地为所有属性提供 getter 和 setter 呢？不建议这样做，因为这样做和将属性定义为 public 没有区别。封装的关键是，根据业务进行分析，有的属性不能修改则不提供 setter，有的属性的修改有限制规则，则需要在 setter 中进行限定，有的属性不希望外界获取则不提供 getter（或声明为私有的），有些方法或者函数仅仅是内部使用的，也可以声明为 private，这些都是具体问题具体分析的。

抽象，是归纳提炼；封装则是在实现中依据业务需求尽量隐藏细节。

## 继承

继承是所有 OOP 语言和 Java 语言不可缺少的组成部分。  

继承是 Java 面向对象编程技术的一块基石，是面向对象的三大特征之一，也是实现软件复用的重要手段，继承可以理解为一个对象从另一个对象获取属性的过程。

如果类 A 是类 B 的父类，而类  B 是类 C 的父类，我们也称类 C 是 A 的子类，类 C 是从类 A 继承而来的。在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类。

继承中最常使用的两个关键字是 **extends** 和 **implements** 。

这两个关键字的使用决定了一个对象和另一个对象是否是 IS-A (是一个)关系。

通过使用这两个关键字，我们能实现一个对象获取另一个对象的属性。

所有 Java 的类均是由 java.lang.Object 类继承而来的，所以 Object 是所有类的祖先类，而除了 Object 外，所有类必须有一个父类。

使用继承是否能够获取父类的一切内容呢？不是，以下是两种特殊的情况。

-   子类无法继承父类的构造方法， 构造方法是一种特殊的方法，子类无法继承父类的构造方法。
   
-   子类不能继承父类中不符合访问权限的成员。
 

我们知道，private 修饰的成员仅对当前类可见，而继承是子类继承父类的成员，显然子类和父类是不同的类，因此子类无法继承父类中用 private 修饰的成员。同理，子类也无法继承父类中不满足 protected 或默认访问权限修饰的成员。如果将父类 Vehicle 中的 name 属性用 private 修饰，并用子类继承此属性，那么编译时就会报错。

## 重写 

>重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！
>
>重写的好处在于子类可以根据需要，定义特定于自己的行为。
>
>也就是说子类能够根据需要实现父类的方法。
>
>子类可以从父类继承可见的成员。但有的时候，父类继承而来的方法不能满足子类的需要，此时就可以在子类中对父类的同名方法进行覆盖，这就是重写。


#### 方法重写的规则

-   参数列表与被重写方法的参数列表必须完全相同。
-   返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
-   子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
-   父类的成员方法只能被它的子类重写。
-   声明为 final 的方法不能被重写。
-   声明为 static 的方法不能被重写，但是能够被再次声明。
-   子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
-   子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
-   重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
-   构造方法不能被重写。
-   如果不能继承一个方法，则不能重写这个方法。
-   访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

### super 关键字

>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。

`super()` 可以调用父类的构造方法。但此时，必须将 `super()`写在子类构造方法的第一行，其语法形式如下。

```java
super( [参数列表] )
```

需要注意的是，子类的构造方法中如果不写 `super()`，编译器会帮助你在子类构造方法的第一行加上`super()`，因为在子类中调用父类构造器是“必须的”。但如果父类中只存在有参构造方法，并没有提供无参构造方法，则需要在子类构造方法中显式地调用父类存在的构造器。

简言之，子类构造方法中调用父类构造方法是“必须的”，如果程序员显式进行了调用，则编译器不提供额外帮助，如果程序员未通过 `super()`来调用，编译器就会帮助你插入`super()`，这时可能因为父类中没有无参构造器而得到一个编译错误。

我们知道构造方法可以用于给属性赋初值，而构造方法又不能被子类继承，那么在使用了继承后，如何同时调用父类和子类的构造方法，从而给所有的属性赋值呢？可以使用 `super()`。

父类中没有无参构造器时，常见处理方式有以下两种：

在子类构造方法第一行显式的通过`super([参数列表])`，调用父类的某一个有参构造方法，如下所示。

```java
public class Sup {
    public Sup( String arg){         
    }
}

class Sub extends Sup {
    public Sub(){
      super("argValue") ;          
      // ..
    }
}
```

先通过`this([参数列表])`调用本类中的其他构造方法，再在其他构造方法中通过`super([参数列表])`显式的调用父类的构造方法，如下所示。

```java
public class Sup {
    public Sup( String arg){
    }
}

class Sub extends Sup {
    public Sub(){
        this(1) ;                   
    }
    public Sub(int a){
        super("argValue") ;         

    }
}
```

不难发现，以上形式的本质其实是一样的，都需要显式的写上`super[参数列表]`。

目前，我们可以通过继承直接沿用父类中已有的方法，并且通过方法重写覆盖父类中的方法。并且知道，当方法被重写以后，子类默认调用的是子类中重写后的方法，但如何调用父类中被重写的那个方法呢？使用 super 关键字，即可以使用 super 明确调用父类中的方法。 请看接下来的程序。

```java
public class Sup {
    public void info(){
        System.out.println("this is super class info");
    }
}

class Sub extends Sup{
    public void info(){
        System.out.println("this is sub class info");
    }

    public void show(){
        info();            
        super.info();       
    }
}
```

因为子类 `Sub` 和父类 `Sup` 都定义了 `info()`方法，因此在子类 `Sub` 的 `show()`中，如果直接编写 `info()`或 `this.info()`，调用的就是 `Sub` 中的 `info()`方法；如果编写的是 `super.info()`，那么就会调用父类 `Sup` 中的 `info()`方法。

## 多态

封装和继承的学习已告一段落，接下来要学习面向对象设计与开发中比较难理解的一个概念—多态。

多态是同一个行为具有多个不同表现形式或形态的能力。

多态性是对象多种表现形式的体现。

比如我们说"宠物"这个对象，它就有很多不同的表达或实现，比如有小猫、小狗、蜥蜴等等。那么我到宠物店说"请给我一只宠物"，服务员给我小猫、小狗或者蜥蜴都可以，我们就说"宠物"这个对象就具备多态性。

在汉语中经常存在着“一词多义”的情景。例如“打”这个字是什么意思呢？“打篮球”、“打水”、“打架”中“打”的含义各不相同，因此要想确定某个具体的“打”字的含义，就必须将“打”放入具体的语境，通过上下文来断定。类似的，在程序开发中也存在着类似于这种“一词多义”的特征——多态。

多态可以优雅的解决程序中的扩展性问题。假设在租车系统中有一个 `drive(Car car)`方法，显然该方法只能传递一个 Car 类型的参数，因此如果想传递一个 Truck 类型的参数，就必须再重新编写一个 `drive(Truck truck)`方法。后续，随着项目的扩大，如果要给 `drive()`方法传递十种类型的参数，就需要根据参数类型编写十个重载的 `drive()`方法。但如果使用多态，这一问题就可以得到很好的解决。

根据继承的知识，可以给 Car 和 Truck 等各种类型的车设置一个共同的父类 `Vehicle`，之后只需要编写一个 `drive(Vehicle vehicle)`方法，就可以接收所有子类型的参数了，即可以使用 `Vehicle` 接收 `Car、Truck` 等各种子类型变量。实际上，Java 就是通过多态机制实现这一功能的。

在逻辑上，多态与继承类似，都符合`is a`的关系，例如`Car is a Vehicle` 、`Truck is a Vehicle` 等。显然，`is a`的左侧是子类，而右侧是父类。这种`is a`的逻辑，就保证了在形式上，父类引用可以指向子类对象，例如`Vehicle vehicle = new Car();`就是多态的一种典型写法。

在`Vehicle vehicle = new Car();`中，子类的 `Car` 对象赋值给了父类 `Vehicle` 引用，这称为向上转型；在引用 `vehicle` 上调用方法，在运行时刻究竟调用的是父类 `Vehicle` 中的方法还是子类 `Car` 中的方法呢？实际需要通过运行时的对象类型来判断，这称为动态绑定。向上转型和动态绑定就是多态的具体实现机制。