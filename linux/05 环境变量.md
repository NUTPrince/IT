# 变量

## 简介

要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量。

所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。

> 变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。

环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。

![[5-1.png]]

通常我们会涉及到的变量类型有三种：

-   当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。
-   Shell 本身内建的变量。
-   从自定义变量导出的环境变量。

也有三个与上述三种环境变量相关的命令：`set`，`env`，`export`。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：

| **命 令** | **说 明** |
|:---:|:---:|
| set | 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 |
| env | 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 |
| export | 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 |

![[5-2.png]]

## 永久生效

但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？

按变量的生存周期来划分，Linux 变量可分为两类：

1.  永久的：需要修改配置文件，变量永久生效；
  
2.  临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。


这里介绍两个重要文件 `/etc/bashrc`（有的 Linux 没有这个文件） 和 `/etc/profile` ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：

```shell
cd ~
```

```shell
ls -a
```

其中有一个` .profile` 文件，它只对当前用户永久生效。因为它保存在当前用户的 Home 目录下，当切换用户时，工作目录可能一并被切换到对应的目录中，这个文件就无法生效。而写在 `/etc/profile` 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 `/etc/profile`，在最后加上你想添加的环境变量。

## 命令查找

查看 `PATH` 环境变量的内容：
```shell
echo $PATH
```


>当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。

## 自定义路径
```bash
PATH=$PATH:/home/nutprince/linux
```

**注意这里一定要使用绝对路径。**

现在你就可以在任意目录执行那两个命令了（注意需要去掉前面的 `./`）。你可能会意识到这样还并没有很好的解决问题，因为我给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，我一旦退出终端，再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。实验楼的环境使用的 Shell 是 zsh，它的配置文件是 `.zshrc`，相应的如果使用的 Shell 是 Bash，则配置文件为 `.bashrc`。它们在 `etc` 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。Shell 的种类有很多，可以使用 `cat /etc/shells` 命令查看当前系统已安装的 Shell。

## 修改和删除已有变量

### 变量修改

变量的修改有以下几种方式：

<table>
<thead>
<tr>
<th>变量设置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>${变量名#匹配字串}</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>${变量名##匹配字串}</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>${变量名%匹配字串}</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>${变量名%%匹配字串}</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>${变量名/旧的字串/新的字串}</code></td>
<td>将符合旧字串的第一个字串替换为新的字串</td>
</tr>
<tr>
<td><code>${变量名//旧的字串/新的字串}</code></td>
<td>将符合旧字串的全部字串替换为新的字串</td>
</tr>
</tbody></table>

### 变量删除

可以使用 `unset` 命令删除一个环境变量：
```shell
unset JAVA_HOME
```

### 环境生效

前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 `.zshrc`），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 `source` 命令来让其立即生效。

```shell
source JAVA_HOME
```

## 搜索文件

与搜索相关的命令常用的有 `whereis`，`which`，`find` 和 `locate`。

1.  `whereis`

>`whereis` 只能搜索二进制文件（`-b`），man 帮助文件（`-m`）和源代码文件（`-s`）。如果想要获得更全面的搜索结果可以使用 `locate` 命令。

```shell
whereis find
```

2. `locate` 

>使用 `locate` 命令查找文件也不会遍历硬盘，它通过查询 `/var/lib/mlocate/mlocate.db` 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 `updatedb` 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 `updatedb` 命令（在我们的环境中必须先执行一次该命令）。

(注意! 这个命令也不是内置的命令，在部分环境中需要手动安装，然后执行更新。)
```shell
sudo apt-get update
```

```shell
sudo apt-get install locate
```

```shell
sudo updatedb
```

它可以用来查找指定目录下的不同文件类型，如查找 `/etc` 下所有以 sh 开头的文件：

```shell
locate /etc/sh
```
(注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。)

查找 `/usr/share/` 下所有 jpg 文件：

```shell
locate /usr/share/*.jpg
```

**报错及解决**

如果其他环境中执行该命令提示 `zsh: no matches found: /usr/share/*.jpg`

-  问题

zsh试图将*通配符展开，在本地未找到对应文件，于是出现“no matches”的错误。

-  解决

>设置nonomatch选项，让zsh匹配失败时不报错并使用原本内容。  
具体做法是在～/.zshrc文件里写入`setopt nonomatch`

```bash
vim ~/.zshrc
```

```shell
setopt nonomatch
```

```shell
source ~/.zshrc
```


如果想只统计数目可以加上 `-c` 参数，`-i` 参数可以忽略大小写进行查找，`whereis` 的 `-b`、`-m`、`-s` 同样可以使用。

3.   `which` 

>`which` 本身是 Shell 内建的一个命令，我们通常使用 `which` 来确定是否安装了某个指定的程序，因为它只从 `PATH` 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。

```shell
which man
```

4. `find` 

>`find` 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。

基本命令格式为 find【path】【option】【action】

```shell
find /etc/ -name interfaces
```
(**注意 find 命令的路径是作为第一个参数的**)

| **参数** | **说明** |
|:---:|:---:|
| \-atime | 最后访问时间 |
| \-ctime | 最后修改文件内容的时间 |
| \-mtime | 最后修改文件属性的时间 |

以 `-mtime` 参数举例：

-   `-mtime n`：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件
-   `-mtime +n`：列出在 n 天之前（不包含 n 天本身）被修改过的文件
-   `-mtime -n`：列出在 n 天之内（包含 n 天本身）被修改过的文件
-   `-newer file`：file 为一个已存在的文件，列出比 file 还要新的文件名


![[5-3.png]]


